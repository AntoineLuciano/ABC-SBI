
@jit
def prior_simulator(key):
    return random.normal(key, (D,)) * SIGMA0 + MU0


@jit
def data_simulator(key, theta):
    return (random.normal(key, (D,N_DATA)) * SIGMA + theta[:,None]).astype(float)


@jit
def discrepancy(y, y_true):
    return jnp.sum((jnp.mean(y, axis= 1) - jnp.mean(y_true, axis =1)) ** 2)


def true_posterior_sample(key, TRUE_DATA, N_SAMPLE):
    TRUE_DATA_i = TRUE_DATA[INDEX_MARGINAL]
    mu_post = (MU0 * SIGMA**2 + SIGMA0**2 * jnp.sum(TRUE_DATA_i)) / (
        SIGMA0**2 * len(TRUE_DATA_i) + SIGMA**2
    )
    sigma2_post = 1 / (1 / SIGMA0**2 + len(TRUE_DATA_i) / SIGMA**2)
    return random.normal(key, (N_SAMPLE,)) * np.sqrt(sigma2_post) + mu_post